{"ast":null,"code":"// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = require('buffer').Buffer;\nvar EventEmitter = require('events').EventEmitter;\nvar bufferAllocUnsafe = require('../lib/utils').bufferAllocUnsafe;\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n  if (!(this instanceof BufferList)) return new BufferList(opts);\n  EventEmitter.call(this);\n  var self = this;\n  if (typeof opts == 'undefined') opts = {};\n\n  // default encoding to use for take(). Leaving as 'undefined'\n  // makes take() return a Buffer instead.\n  self.encoding = opts.encoding;\n  var head = {\n    next: null,\n    buffer: null\n  };\n  var last = {\n    next: null,\n    buffer: null\n  };\n\n  // length can get negative when advanced past the end\n  // and this is the desired behavior\n  var length = 0;\n  self.__defineGetter__('length', function () {\n    return length;\n  });\n\n  // keep an offset of the head to decide when to head = head.next\n  var offset = 0;\n\n  // Write to the bufferlist. Emits 'write'. Always returns true.\n  self.write = function (buf) {\n    if (!head.buffer) {\n      head.buffer = buf;\n      last = head;\n    } else {\n      last.next = {\n        next: null,\n        buffer: buf\n      };\n      last = last.next;\n    }\n    length += buf.length;\n    self.emit('write', buf);\n    return true;\n  };\n  self.end = function (buf) {\n    if (Buffer.isBuffer(buf)) self.write(buf);\n  };\n\n  // Push buffers to the end of the linked list. (deprecated)\n  // Return this (self).\n  self.push = function () {\n    var args = [].concat.apply([], arguments);\n    args.forEach(self.write);\n    return self;\n  };\n\n  // For each buffer, perform some action.\n  // If fn's result is a true value, cut out early.\n  // Returns this (self).\n  self.forEach = function (fn) {\n    if (!head.buffer) return bufferAllocUnsafe(0);\n    if (head.buffer.length - offset <= 0) return self;\n    var firstBuf = head.buffer.slice(offset);\n    var b = {\n      buffer: firstBuf,\n      next: head.next\n    };\n    while (b && b.buffer) {\n      var r = fn(b.buffer);\n      if (r) break;\n      b = b.next;\n    }\n    return self;\n  };\n\n  // Create a single Buffer out of all the chunks or some subset specified by\n  // start and one-past the end (like slice) in bytes.\n  self.join = function (start, end) {\n    if (!head.buffer) return bufferAllocUnsafe(0);\n    if (start == undefined) start = 0;\n    if (end == undefined) end = self.length;\n    var big = bufferAllocUnsafe(end - start);\n    var ix = 0;\n    self.forEach(function (buffer) {\n      if (start < ix + buffer.length && ix < end) {\n        // at least partially contained in the range\n        buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n      }\n      ix += buffer.length;\n      if (ix > end) return true; // stop processing past end\n    });\n\n    return big;\n  };\n  self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n    if (!head.buffer) return new bufferAllocUnsafe(0);\n    if (sourceStart == undefined) sourceStart = 0;\n    if (sourceEnd == undefined) sourceEnd = self.length;\n    var big = targetBuffer;\n    if (big.length - targetStart < sourceEnd - sourceStart) {\n      throw new Error(\"Insufficient space available in target Buffer.\");\n    }\n    var ix = 0;\n    self.forEach(function (buffer) {\n      if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n        // at least partially contained in the range\n        buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n      }\n      ix += buffer.length;\n      if (ix > sourceEnd) return true; // stop processing past end\n    });\n\n    return big;\n  };\n\n  // Advance the buffer stream by n bytes.\n  // If n the aggregate advance offset passes the end of the buffer list,\n  // operations such as .take() will return empty strings until enough data is\n  // pushed.\n  // Returns this (self).\n  self.advance = function (n) {\n    offset += n;\n    length -= n;\n    while (head.buffer && offset >= head.buffer.length) {\n      offset -= head.buffer.length;\n      head = head.next ? head.next : {\n        buffer: null,\n        next: null\n      };\n    }\n    if (head.buffer === null) last = {\n      next: null,\n      buffer: null\n    };\n    self.emit('advance', n);\n    return self;\n  };\n\n  // Take n bytes from the start of the buffers.\n  // Returns a string.\n  // If there are less than n bytes in all the buffers or n is undefined,\n  // returns the entire concatenated buffer string.\n  self.take = function (n, encoding) {\n    if (n == undefined) n = self.length;else if (typeof n !== 'number') {\n      encoding = n;\n      n = self.length;\n    }\n    var b = head;\n    if (!encoding) encoding = self.encoding;\n    if (encoding) {\n      var acc = '';\n      self.forEach(function (buffer) {\n        if (n <= 0) return true;\n        acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n        n -= buffer.length;\n      });\n      return acc;\n    } else {\n      // If no 'encoding' is specified, then return a Buffer.\n      return self.join(0, n);\n    }\n  };\n\n  // The entire concatenated buffer as a string.\n  self.toString = function () {\n    return self.take('binary');\n  };\n}\nrequire('util').inherits(BufferList, EventEmitter);","map":{"version":3,"names":["Buffer","require","EventEmitter","bufferAllocUnsafe","module","exports","BufferList","opts","call","self","encoding","head","next","buffer","last","length","__defineGetter__","offset","write","buf","emit","end","isBuffer","push","args","concat","apply","arguments","forEach","fn","firstBuf","slice","b","r","join","start","undefined","big","ix","copy","Math","max","min","joinInto","targetBuffer","targetStart","sourceStart","sourceEnd","Error","advance","n","take","acc","toString","inherits"],"sources":["/home/ubuntu/Projects/digital_trading/frontend/my-react-app/node_modules/websocket/vendor/FastBufferList.js"],"sourcesContent":["// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = require('buffer').Buffer;\nvar EventEmitter = require('events').EventEmitter;\nvar bufferAllocUnsafe = require('../lib/utils').bufferAllocUnsafe;\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    \n    if (typeof(opts) == 'undefined') opts = {};\n    \n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    \n    var head = { next : null, buffer : null };\n    var last = { next : null, buffer : null };\n    \n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__('length', function () {\n        return length;\n    });\n    \n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    \n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function (buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        }\n        else {\n            last.next = { next : null, buffer : buf };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit('write', buf);\n        return true;\n    };\n    \n    self.end = function (buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    \n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function () {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    \n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function (fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        \n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        \n        var b = { buffer : firstBuf, next : head.next };\n        \n        while (b && b.buffer) {\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        \n        return self;\n    };\n    \n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function (start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        \n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (start < (ix + buffer.length) && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(0, ix - start),\n                    Math.max(0, start - ix),\n                    Math.min(buffer.length, end - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        \n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(targetStart, targetStart + ix - sourceStart),\n                    Math.max(0, sourceStart - ix),\n                    Math.min(buffer.length, sourceEnd - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function (n) {\n        offset += n;\n        length -= n;\n        while (head.buffer && offset >= head.buffer.length) {\n            offset -= head.buffer.length;\n            head = head.next\n                ? head.next\n                : { buffer : null, next : null }\n            ;\n        }\n        if (head.buffer === null) last = { next : null, buffer : null };\n        self.emit('advance', n);\n        return self;\n    };\n    \n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function (n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== 'number') {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = '';\n            self.forEach(function (buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(\n                    encoding, 0, Math.min(n,buffer.length)\n                );\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    \n    // The entire concatenated buffer as a string.\n    self.toString = function () {\n        return self.take('binary');\n    };\n}\nrequire('util').inherits(BufferList, EventEmitter);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}